#define _CRT_SECURE_NO_WARNINGS

#define ERROR 1
#define MAX_NAME 256
#define MAX_LINE 1024

#include <stdio.h>
#include <stdlib.h>

struct _Polinom;
typedef struct _Polinom* pos;
typedef struct _Polinom {
	int coef;
	int exp;

	pos* next;
}Polinom;

int Read();
int Add(pos);
int Multiply(pos);
int Sort(pos);

int main() {
	int izbor;
	Polinom Head = { .coef = 0, .exp = 0 , .next = NULL };

	Read();

	printf("Do you want to add or multiply your polynomes?\nIf you want to add them choose 1\nIf you want to multiply them choose 2\n");
	scanf("%d", &izbor);
	
	while (1) {
		if (izbor == 1) {
			Add(&Head);
		}
		else if (izbor == 2) {
			Multiply(&Head);
		}
		else {
			printf("Wrong choice.");
			break;
		}
	}

	return EXIT_SUCCESS;
}

int Read() {
	char filename[MAX_NAME] = { 0 };
	int buffer[MAX_LINE] = { 0 };
	int a = 0;
	int i = 0;
	Polinom Head;
	Head.next = NULL;
	pos p = &Head;
	pos q = NULL;

	printf("Enter file name: ");
	scanf(" %s", filename);

	FILE* fp = NULL;
	fp = fopen(filename, "r");

	if (fp == NULL) {
		printf("Greska u otvaranju datoteke!\n");
		return ERROR;
	}

	while (!feof(fp)) {
		if (fgetc(fp) == "\n") {
			a++;
		}
	}
	if (a != 0) {
		for (i = 0; i < a; i++) {
			q = (pos)malloc(sizeof(Polinom));
			if (q == NULL) {
				printf("Neuspjesna alokacija memorije!\n");
				return ERROR;
			}
			sscanf(fp, "%d %d", q->coef, q->exp);
			q->next = p->next;
			p->next = q;
			p = p->next;
		}
	}
	fclose(fp);
	printf(Head.next);
	return EXIT_SUCCESS;
}

/*int Add(pos p) {
	char filename[MAX_NAME] = { 0 };
	int buffer[MAX_LINE] = { 0 };

	printf("Enter file name: ");
	scanf(" %s", filename);

	FILE* fp = NULL;
	fp = fopen(filename, "r");

	/*fgets(buffer, MAX_LINE,fp);
	sscanf(p, "%d %d %n", &coef, &exp, &numofbytes);
	fclose(fp);
	return EXIT_SUCCESS;
}*/

int Multiply(pos p) {

	return EXIT_SUCCESS;
}

/*int Sort(pos p) {
	pos q = NULL;
	pos prev = NULL;
	pos temp = NULL;
	pos last = NULL;

	while (p->next != last) {
		prev = p;
		q = p->next;
		while (q->next != last) {
			if (q->exp==(q->next->exp)) {
				temp = q->next;
				prev->next = temp;
				q->next = temp->next;
				temp->next = q;

				q = temp;
			}
			prev = q;
			q = q->next;
		}
		last = q;
	}
	return EXIT_SUCCESS;
}*/
